---
title: "Case Study: GLP1 receptor agonists"
author: "rxref authors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: GLP1 receptor agonists}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# Determine whether to run API calls
online_env <- identical(Sys.getenv("BUILD_VIGNETTES_ONLINE"), "true")

# Determine whether actual internet availability
has_net <- tryCatch({
  if (requireNamespace("curl", quietly = TRUE)) curl::has_internet() else FALSE
}, error = function(e) FALSE)

run_live <- online_env && has_net

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(rxref)
library(dplyr)
```

## Case

Suppose we have a need to identify all glucagon-like peptide-1 receptor agonist (GLP1-RA) users from either EHR prescribing data, or pharmacy claims data (or both). To accomplish this, we need a complete list of RxCUIs and their corresponding NDCs (when available). 

## The Set-up

First, we need to clarify the set of drugs that are considered part of the GLP1-RA class. A quick google search will give us the list of GLP1-RA agents currently approved for use:
- exenatide
- liraglutide
- lixisenatide
- dulaglutide
- albiglutide
- semaglutide
- tirzepatide


## Identifying Ingredient RxCUIs

Let's turn this into a character vector and use `find_ingredients()` to gather RxCUIs for TTY = 'IN' (note: you can get a complete list of TTYs and their description from `tty_catalogue()`).

```{r ings}
glp1.names <- c("semaglutide", "exenatide", "liraglutide", "lixisenatide", "dulaglutide", "albiglutide", "tirzepatide")

if (run_live) {
  glp1.ings <- find_ingredients(glp1.names)
} else {
  glp1.ings <- readRDS(system.file("extdata", "glp1_ings.rds", package = "rxref"))
}

glp1.ings
```

## Getting Product RxCUIs from Ingredient RxCUIs

Now, let's look for all of the related RxCUIs using `product_from_ingredients()`. Here, we're going to just focus on the TTYs that are likely to have NDCs (SCD, SBD, GPCK, BPCK) by using the function's default TTY. 

There are two default TTY lists:
- **.rxref_default_ttys** = "SCD", "SBD", "GPCK", "BPCK"
- **.rxref_extended_ttys** = "SCD","SBD","GPCK","BPCK","SCDC","SBDC","SCDF","SBDF","SCDFP","SBDFP","SCDG","SCDGP","BN","MIN","IN"

But, you could supply your own set of TTYs to include instead of using these two default lists.

Lastly, we're going to include combination products (i.e., if they have a GLP1-RA plus one or more other drugs), again using the function's default option of include_combo = TRUE.

```{r prods}
if (run_live) {
  glp1.prods <- products_for_ingredients(glp1.ings$rxcui)
} else {
  glp1.prods <- readRDS(system.file("extdata", "glp1_prods.rds", package = "rxref"))
}

glp1.prods |> head(30)
```

## Adding in NDCs from Product RxCUIs

Now, let's identify the related NDCs for each RxCUI. Note that not all RxCUIs will link to NDCs, so some NAs will likely show up in the resulting file.

```{r ndcs}
if (run_live) {
  glp1.ndc.map <- map_rxcui_to_ndc(unique(glp1.prods$product_rxcui))
} else {
  glp1.ndc.map <- readRDS(system.file("extdata", "glp1_ndc_map.rds", package = "rxref"))
}

# Join back names/TTYs and de-dupe
glp1_ndcs <- glp1.ndc.map |> 
  dplyr::left_join(glp1.prods, by = c("rxcui" = "product_rxcui")) |> 
  dplyr::distinct(rxcui, ingredient_rxcui, ndc11, name, tty) |> 
  dplyr::arrange(ingredient_rxcui, rxcui, ndc11, name)

glp1.ndcs <- dplyr::left_join(
  x = glp1_ndcs,
  y = glp1.ings |> dplyr::select(rxcui, name) |> dplyr::rename(ingredient = name, ingredient_rxcui = rxcui),
  by = "ingredient_rxcui"
)

glp1.ndcs |> head(30)
```

Voila, we now have a complete list of GLP1-RAs that can be used to query against the prescribing data or pharmacy claims data. 
## An Alternate Approach

This same goal can be accomplished all in one step, if you prefer, using the `search_drug()` function. Suppose we want to just get NDCs, and we want to make sure we're capturing *active*, as well as *obsolete* or *unspecified* NDCs. That is, we don't actually care about the RxCUIs that don't have a corresponding NDC. 

```{r search}

if (run_live) {
  alt.glp1.ndcs <- search_drug(term = glp1.names,
                               return = "ndc",
                               ndc_status = c("ACTIVE", "OBSOLETE", "UNSPECIFIED")
                               )
} else {
  alt.glp1.ndcs <- readRDS(system.file("extdata", "alt_glp1_ndc.rds", package = "rxref"))
}

alt.glp1.ndcs1 <- 
  dplyr::left_join(alt.glp1.ndcs, glp1.prods |> select(-ingredient_rxcui), by = c("product_rxcui" = "product_rxcui")) |> 
  dplyr::distinct(product_rxcui, ingredient_rxcui, ndc11, name, tty) |> 
  dplyr::arrange(ingredient_rxcui, product_rxcui, ndc11, name)
alt.glp1.ndcs2 <- dplyr::left_join(
  x = alt.glp1.ndcs1,
  y = glp1.ings |> dplyr::select(rxcui, name) |> dplyr::rename(ingredient = name, ingredient_rxcui = rxcui),
  by = "ingredient_rxcui")
alt.glp1.ndcs2 
```

Compare that against the original table, filtered for non-NA `ndc11` values:

```{r check}
glp1.ndcs |> filter(!is.na(ndc11))
```
